var SHAObj=function(){"use strict";
/**
     * [SHAObj]{@link https://github.com/UmamiAppearance/BrowserSHAObj}
     *
     * @version 1.0.2
     * @author UmamiAppearance [mail@umamiappearance.eu]
     * @license MIT
     */const t=["SHA-1","SHA-256","SHA-384","SHA-512"];let e;"undefined"!=typeof BaseEx&&(e="BaseEx"in BaseEx?new BaseEx.BaseEx:new BaseEx);return class{#t=null;#e=null;#i=null;#s=[];constructor(i="SHA-256"){const s=this.constructor.algorithmsAvailable();if(this.#e=0|[].concat(String(i).match(/[0-9]+/)).at(0),this.#t=`SHA-${this.#e}`,1===this.#e&&(this.#e=160),!s.has(this.#t))throw new TypeError(`Available algorithms are: '${t.join(", ")}'.`);e&&this.#r()}static baseEx=e;static algorithmsAvailable(){return new Set(t)}static algorithmsGuaranteed(){return this.constructor.algorithmsAvailable()}static async new(t="SHA-256",e=null){const i=new this(t);return null!==e&&await i.update(e),i}get digestSize(){return this.#e/8}get blockSize(){return this.#e>256?128:64}get name(){return this.#t}async copy(){const t=this.#s.length?Uint8Array.from(this.#s):null;return this.constructor.new(this.#t,t)}async update(t,i=!1){if(t instanceof ArrayBuffer)t=new Uint8Array(t);else if(ArrayBuffer.isView(t))t=new Uint8Array(t.buffer);else{if(!e)throw new TypeError("You need BaseEx if you like to digest anything other than byte-like input.");t=e.byteConverter.encode(t,"uint8")}let s;t.byteLength<2e8?(this.#s=i?Array.from(t):this.#s.concat(Array.from(t)),s=Uint8Array.from(this.#s),s.byteLength>5e8&&!this.warned&&(console.warn("The stored input is getting really big. Dependent from your environment this can lead to memory issues."),this.warned=!0)):(console.warn("Input gets too big to safely store it in memory. It will get processed directly and neither stored nor concatenated to previous input. If the operation fails, it is due to memory issues."),s=t),this.#i=await globalThis.crypto.subtle.digest(this.#t,s)}async replace(t){await this.update(t,!0)}digest(){return this.#i}hexdigest(){return this.#i?Array.from(new Uint8Array(this.#i)).map((t=>t.toString(16).padStart(2,"0"))).join(""):null}#r(){const t=(t,e)=>t.splice(t.indexOf(e),1),i=t=>t.charAt(0).toUpperCase().concat(t.slice(1)),s=Object.keys(e);this.basedigest={toSimpleBase:{}},t(s,"base1"),t(s,"byteConverter"),t(s,"simpleBase");for(const t of s)this.basedigest[`to${i(t)}`]=(...i)=>this.#i?e[t].encode(this.#i,...i):null;for(const t in e.simpleBase)this.basedigest.toSimpleBase[i(t)]=(...i)=>this.#i?e.simpleBase[t].encode(this.#i,...i):null;this.basedigest.toBytes=(...t)=>this.#i?e.byteConverter.encode(this.#i,...t):null}}}();
